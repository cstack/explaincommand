<!-- Creator     : groff version 1.22.4 -->
<!-- CreationDate: Sat Nov 12 15:40:18 2022 -->
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta name="generator" content="groff -Thtml, see www.gnu.org">
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<meta name="Content-Style" content="text/css">
<style type="text/css">
       p       { margin-top: 0; margin-bottom: 0; vertical-align: top }
       pre     { margin-top: 0; margin-bottom: 0; vertical-align: top }
       table   { margin-top: 0; margin-bottom: 0; vertical-align: top }
       h1      { text-align: center }
</style>
<title></title>
</head>
<body>

<hr>


<p>GIT-UPDATE-REF(1) Git Manual GIT-UPDATE-REF(1)</p>

<p style="margin-top: 1em">NAME <br>
git-update-ref - Update the object name stored in a ref
safely</p>

<p style="margin-top: 1em">SYNOPSIS <br>
git update-ref [-m &lt;reason&gt;] [--no-deref] (-d
&lt;ref&gt; [&lt;oldvalue&gt;] | [--create-reflog]
&lt;ref&gt; &lt;newvalue&gt; [&lt;oldvalue&gt;] | --stdin
[-z])</p>

<p style="margin-top: 1em">DESCRIPTION <br>
Given two arguments, stores the &lt;newvalue&gt; in the
&lt;ref&gt;, possibly <br>
dereferencing the symbolic refs. E.g. git update-ref HEAD
&lt;newvalue&gt; <br>
updates the current branch head to the new object.</p>

<p style="margin-top: 1em">Given three arguments, stores
the &lt;newvalue&gt; in the &lt;ref&gt;, possibly <br>
dereferencing the symbolic refs, after verifying that the
current value <br>
of the &lt;ref&gt; matches &lt;oldvalue&gt;. E.g. git
update-ref refs/heads/master <br>
&lt;newvalue&gt; &lt;oldvalue&gt; updates the master branch
head to &lt;newvalue&gt; only <br>
if its current value is &lt;oldvalue&gt;. You can specify 40
&quot;0&quot; or an empty <br>
string as &lt;oldvalue&gt; to make sure that the ref you are
creating does <br>
not exist.</p>

<p style="margin-top: 1em">It also allows a &quot;ref&quot;
file to be a symbolic pointer to another ref <br>
file by starting with the four-byte header sequence of
&quot;ref:&quot;.</p>

<p style="margin-top: 1em">More importantly, it allows the
update of a ref file to follow these <br>
symbolic pointers, whether they are symlinks or these
&quot;regular file <br>
symbolic refs&quot;. It follows real symlinks only if they
start with <br>
&quot;refs/&quot;: otherwise it will just try to read them
and update them as a <br>
regular file (i.e. it will allow the filesystem to follow
them, but <br>
will overwrite such a symlink to somewhere else with a
regular <br>
filename).</p>

<p style="margin-top: 1em">If --no-deref is given,
&lt;ref&gt; itself is overwritten, rather than the <br>
result of following the symbolic pointers.</p>

<p style="margin-top: 1em">In general, using</p>

<p style="margin-top: 1em">git update-ref HEAD
&quot;$head&quot;</p>

<p style="margin-top: 1em">should be a lot safer than
doing</p>

<p style="margin-top: 1em">echo &quot;$head&quot; &gt;
&quot;$GIT_DIR/HEAD&quot;</p>

<p style="margin-top: 1em">both from a symlink following
standpoint and an error checking <br>
standpoint. The &quot;refs/&quot; rule for symlinks means
that symlinks that <br>
point to &quot;outside&quot; the tree are safe:
they&acirc;ll be followed for reading <br>
but not for writing (so we&acirc;ll never write through a
ref symlink to some <br>
other tree, if you have copied a whole archive by creating a
symlink <br>
tree).</p>

<p style="margin-top: 1em">With -d flag, it deletes the
named &lt;ref&gt; after verifying it still <br>
contains &lt;oldvalue&gt;.</p>

<p style="margin-top: 1em">With --stdin, update-ref reads
instructions from standard input and <br>
performs all modifications together. Specify commands of the
form:</p>

<p style="margin-top: 1em">update SP &lt;ref&gt; SP
&lt;newvalue&gt; [SP &lt;oldvalue&gt;] LF <br>
create SP &lt;ref&gt; SP &lt;newvalue&gt; LF <br>
delete SP &lt;ref&gt; [SP &lt;oldvalue&gt;] LF <br>
verify SP &lt;ref&gt; [SP &lt;oldvalue&gt;] LF <br>
option SP &lt;opt&gt; LF <br>
start LF <br>
prepare LF <br>
commit LF <br>
abort LF</p>

<p style="margin-top: 1em">With --create-reflog, update-ref
will create a reflog for each ref even <br>
if one would not ordinarily be created.</p>

<p style="margin-top: 1em">Quote fields containing
whitespace as if they were strings in C source <br>
code; i.e., surrounded by double-quotes and with backslash
escapes. Use <br>
40 &quot;0&quot; characters or the empty string to specify a
zero value. To <br>
specify a missing value, omit the value and its preceding SP
entirely.</p>

<p style="margin-top: 1em">Alternatively, use -z to specify
in NUL-terminated format, without <br>
quoting:</p>

<p style="margin-top: 1em">update SP &lt;ref&gt; NUL
&lt;newvalue&gt; NUL [&lt;oldvalue&gt;] NUL <br>
create SP &lt;ref&gt; NUL &lt;newvalue&gt; NUL <br>
delete SP &lt;ref&gt; NUL [&lt;oldvalue&gt;] NUL <br>
verify SP &lt;ref&gt; NUL [&lt;oldvalue&gt;] NUL <br>
option SP &lt;opt&gt; NUL <br>
start NUL <br>
prepare NUL <br>
commit NUL <br>
abort NUL</p>

<p style="margin-top: 1em">In this format, use 40
&quot;0&quot; to specify a zero value, and use the empty
<br>
string to specify a missing value.</p>

<p style="margin-top: 1em">In either format, values can be
specified in any form that Git <br>
recognizes as an object name. Commands in any other format
or a <br>
repeated &lt;ref&gt; produce an error. Command meanings
are:</p>

<p style="margin-top: 1em">update <br>
Set &lt;ref&gt; to &lt;newvalue&gt; after verifying
&lt;oldvalue&gt;, if given. <br>
Specify a zero &lt;newvalue&gt; to ensure the ref does not
exist after <br>
the update and/or a zero &lt;oldvalue&gt; to make sure the
ref does not <br>
exist before the update.</p>

<p style="margin-top: 1em">create <br>
Create &lt;ref&gt; with &lt;newvalue&gt; after verifying it
does not exist. The <br>
given &lt;newvalue&gt; may not be zero.</p>

<p style="margin-top: 1em">delete <br>
Delete &lt;ref&gt; after verifying it exists with
&lt;oldvalue&gt;, if given. <br>
If given, &lt;oldvalue&gt; may not be zero.</p>

<p style="margin-top: 1em">verify <br>
Verify &lt;ref&gt; against &lt;oldvalue&gt; but do not
change it. If &lt;oldvalue&gt; <br>
is zero or missing, the ref must not exist.</p>

<p style="margin-top: 1em">option <br>
Modify behavior of the next command naming a &lt;ref&gt;.
The only valid <br>
option is no-deref to avoid dereferencing a symbolic
ref.</p>

<p style="margin-top: 1em">start <br>
Start a transaction. In contrast to a non-transactional
session, a <br>
transaction will automatically abort if the session ends
without an <br>
explicit commit. This command may create a new empty
transaction <br>
when the current one has been committed or aborted
already.</p>

<p style="margin-top: 1em">prepare <br>
Prepare to commit the transaction. This will create lock
files for <br>
all queued reference updates. If one reference could not be
locked, <br>
the transaction will be aborted.</p>

<p style="margin-top: 1em">commit <br>
Commit all reference updates queued for the transaction,
ending the <br>
transaction.</p>

<p style="margin-top: 1em">abort <br>
Abort the transaction, releasing all locks if the
transaction is in <br>
prepared state.</p>

<p style="margin-top: 1em">If all &lt;ref&gt;s can be
locked with matching &lt;oldvalue&gt;s simultaneously, <br>
all modifications are performed. Otherwise, no modifications
are <br>
performed. Note that while each individual &lt;ref&gt; is
updated or deleted <br>
atomically, a concurrent reader may still see a subset of
the <br>
modifications.</p>

<p style="margin-top: 1em">LOGGING UPDATES <br>
If config parameter &quot;core.logAllRefUpdates&quot; is
true and the ref is one <br>
under &quot;refs/heads/&quot;, &quot;refs/remotes/&quot;,
&quot;refs/notes/&quot;, or a pseudoref <br>
like HEAD or ORIG_HEAD; or the file
&quot;$GIT_DIR/logs/&lt;ref&gt;&quot; exists then <br>
git update-ref will append a line to the log file
&quot;$GIT_DIR/logs/&lt;ref&gt;&quot; <br>
(dereferencing all symbolic refs before creating the log
name) <br>
describing the change in ref value. Log lines are formatted
as:</p>

<p style="margin-top: 1em">oldsha1 SP newsha1 SP committer
LF</p>

<p style="margin-top: 1em">Where &quot;oldsha1&quot; is the
40 character hexadecimal value previously stored <br>
in &lt;ref&gt;, &quot;newsha1&quot; is the 40 character
hexadecimal value of &lt;newvalue&gt; <br>
and &quot;committer&quot; is the committer&acirc;s name,
email address and date in the <br>
standard Git committer ident format.</p>

<p style="margin-top: 1em">Optionally with -m:</p>

<p style="margin-top: 1em">oldsha1 SP newsha1 SP committer
TAB message LF</p>

<p style="margin-top: 1em">Where all fields are as
described above and &quot;message&quot; is the value <br>
supplied to the -m option.</p>

<p style="margin-top: 1em">An update will fail (without
changing &lt;ref&gt;) if the current user is <br>
unable to create a new log file, append to the existing log
file or <br>
does not have committer information available.</p>

<p style="margin-top: 1em">GIT <br>
Part of the git(1) suite</p>

<p style="margin-top: 1em">Git 2.37.0 06/27/2022
GIT-UPDATE-REF(1)</p>
<hr>
</body>
</html>
